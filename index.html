<!DOCTYPE html>
<html>
<head>
    <title>10K Clash Royale update 10000</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; }
        canvas { display: block; }
        #bottomGif {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            z-index: 10;
            pointer-events: none;
        }
    </style>
</head>
<body>

<img id="bottomGif" src="https://media.tenor.com/j_MxsHf3fXIAAAAM/clash-royale-clash-mini.gif">

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

/* Scene */
const scene = new THREE.Scene();

/* Background image*/ 
const loader = new THREE.TextureLoader();
loader.load('https://support.supercell.com/images/_sidebarPortrait/CR-hamburger-for-portrait.jpg?v=1762334933', function(texture){
    scene.background = texture;

    /*scene.background = new THREE.Color(0x222222);*/

});

/* Camera */
const camera = new THREE.PerspectiveCamera(
    window.innerWidth < 600 ? 85 : 75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
);
camera.position.set(0, 8, 15);
camera.lookAt(0, 4, 0);

/* Renderer */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* Controls */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.minDistance = 6;
controls.maxDistance = 30;
controls.maxPolarAngle = Math.PI / 1.8;

/* Materials */
const blueMaterial = new THREE.MeshStandardMaterial({ color: 0x228BEE, roughness: 0.4, metalness: 0.3 });
const goldMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 1, roughness: 0.3 });
const cakeHeight = 3;
const cakeRadius = 3;

/* Cake base with blue frosting */
const cakeGeometry = new THREE.CylinderGeometry(cakeRadius, cakeRadius, cakeHeight, 64);
const cakeMesh = new THREE.Mesh(cakeGeometry, blueMaterial);
cakeMesh.position.y = cakeHeight/2;
scene.add(cakeMesh);
 

/* Gold piping BORDER frosting*/
const borderGroup = new THREE.Group();
scene.add(borderGroup);

const borderCount = 32;

for (let i = 0; i < borderCount; i++) {
    const angle = (i / borderCount) * Math.PI * 2;
    const x = Math.cos(angle) * cakeRadius * 0.95;
    const z = Math.sin(angle) * cakeRadius * 0.95;

    // swirled piping dollop
    const geo = new THREE.TorusKnotGeometry(0.22, 0.08, 64, 12, 2, 3);
;
    const mat = new THREE.MeshStandardMaterial({
        color: 0xFFD700,
        metalness: 0.4,
        roughness: 0.3
    });

    const blob = new THREE.Mesh(geo, mat);
    blob.position.set(x, cakeHeight + 0.1, z);

    borderGroup.add(blob);
}

/* Bottom Frosting Border */
const bottomBorder = new THREE.Group();
scene.add(bottomBorder);

const bottomCount = 32;
const bottomRadius = cakeRadius * 0.95;

for (let i = 0; i < bottomCount; i++) {
    const angle = (i / bottomCount) * Math.PI * 2;
    const x = Math.cos(angle) * bottomRadius;
    const z = Math.sin(angle) * bottomRadius;

    const dollop = new THREE.Mesh(
        new THREE.TorusKnotGeometry(0.22, 0
,
        goldMaterial 
    );

    dollop.scale.set(1, 0.65, 1);
    dollop.position.set(x, 0.15, z);

    bottomBorder.add(dollop);
} 

/* Floating Text */
const fontLoader = new FontLoader();
fontLoader.load("https://threejs.org/examples/fonts/helvetiker_regular.typeface.json", (font) => {
    const textGeo = new TextGeometry("CONGRATS ON 10,000!!!", {
        font: font,
        size: 0.8,
        height: 0.2,
        curveSegments: 12
    });
    textGeo.center();
    const textMesh = new THREE.Mesh(textGeo, goldMaterial);
    textMesh.position.y = cakeHeight + 2.5;
    scene.add(textMesh);
});

/* Falling Confetti using your image */
const confettiGroup = new THREE.Group();
scene.add(confettiGroup);
const confTexture = loader.load('https://event.supercell.com/clashroyale/images/landing/crown.png');

function createFallingConfetti() {
    const geo = new THREE.PlaneGeometry(0.5, 0.5);
    const mat = new THREE.MeshBasicMaterial({ map: confTexture, transparent: true });
    const confetti = new THREE.Mesh(geo, mat);
    confetti.position.set((Math.random()-0.5)*10, Math.random()*5 + 5, (Math.random()-0.5)*10);
    confetti.rotationSpeed = Math.random()*0.05;
    confetti.fallSpeed = Math.random()*0.05 + 0.02;
    confettiGroup.add(confetti);
}
for(let i=0;i<100;i++) createFallingConfetti();

/* Cake toppers (3) */
const topperGroup = new THREE.Group();
scene.add(topperGroup);

// 3 topper angles in a semicircle facing the camera
const topperAngles = [
    -Math.PI / 2.5,   // farther left
     0,
     Math.PI / 2.5    // farther right
];

// Placeholder materials (visible!)
const placeholderColors = [0xff5555, 0x55ff55, 0x5555ff];

// SIZE of topper image
const TOPPER_WIDTH = 2;
const TOPPER_HEIGHT = 2;

// Stick height
const STICK_HEIGHT = 2;

for (let i = 0; i < 3; i++) {

    /* ----------- Topper Plane (placeholder square) ---------- */
    const planeGeo = new THREE.PlaneGeometry(TOPPER_WIDTH, TOPPER_HEIGHT);

    // bright placeholders so it's impossible to miss
    const planeMat = new THREE.MeshBasicMaterial({
        color: placeholderColors[i],
        side: THREE.DoubleSide
    });

    const topperPlane = new THREE.Mesh(planeGeo, planeMat);
    topperPlane.position.y = STICK_HEIGHT;   // sits on top of stick
    topperPlane.lookAt(camera.position);     // always faces viewer

    /* ----------- Stick ------------ */
    const stickGeo = new THREE.CylinderGeometry(0.05, 0.05, STICK_HEIGHT);
    const stickMat = new THREE.MeshStandardMaterial({ color: 0x804000 });
    const stick = new THREE.Mesh(stickGeo, stickMat);

    stick.position.y = STICK_HEIGHT / 2;

    /* ----------- Group topper + stick ----------- */
    const group = new THREE.Group();
    group.add(stick);
    group.add(topperPlane);

    /* ----------- Position on cake (semicircle) ----------- */
    const angle = topperAngles[i];
    const radius = cakeRadius * 0.8;

    group.position.set(
        Math.cos(angle) * radius,
        cakeHeight + 0.1,   // slightly above frosting
        Math.sin(angle) * radius
    );


    // tilt slightly toward the viewer for cuteness
    group.rotation.y = -angle;

    topperGroup.add(group);
}

function replaceTopperImage(index, url) {
    const loader = new THREE.TextureLoader();
    loader.load(url, (tex) => {
        const topper = topperGroup.children[index].children.find(
            c => c.geometry.type === "PlaneGeometry"
        );
        topper.material.map = tex;
        topper.material.color.set(0xffffff);
        topper.material.transparent = true;
        topper.material.needsUpdate = true;
    });
}

replaceTopperImage(0, "https://www.freeiconspng.com/uploads/clash-royale-png-free-vector-download-1.png");
replaceTopperImage(1, "https://www.freeiconspng.com/uploads/clash-royale-png-free-vector-download-1.png");
replaceTopperImage(2, "https://www.freeiconspng.com/uploads/clash-royale-png-free-vector-download-1.png");

/* Lights */
scene.add(new THREE.AmbientLight(0xffffff,0.8));
const dirLight = new THREE.DirectionalLight(0xffffff,1.5);
dirLight.position.set(5,15,10);
scene.add(dirLight);

/* Animate */
function animate(){
    requestAnimationFrame(animate);

    // Confetti animation
    confettiGroup.children.forEach(c=>{
        c.position.y -= c.fallSpeed;
        c.rotation.x += c.rotationSpeed;
        c.rotation.y += c.rotationSpeed;
        if(c.position.y<-1){
            c.position.y = Math.random()*5 +5;
            c.position.x = (Math.random()-0.5)*10;
            c.position.z = (Math.random()-0.5)*10;
        }
    });

    controls.update();
    renderer.render(scene, camera);
}
animate();

/* Resize */
window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
